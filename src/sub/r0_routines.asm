.ASSUME ADL=0

r0rc_ret_stack_entry .EQU 6
;r0rc_ret_handler     .EQU 4

r0_romcaller: ;-8
	PUSH AF \ PUSH HL \ PUSH DE
	LD HL,r0rc_ret_stack_entry
	ADD HL,SP
	LD DE,(HL)  ;FETCH RETURN ADDRESS FROM STACK
	LD A,(DE)   ;READ DATA 1 BYTE AT RETURN ADDRESS
	INC DE
	INC DE
	LD (HL),DE  ;SKIP OVER DATA BYTES AND PUSH BACK RETURN ADDRESS TO STACK
	EX DE,HL    ;POINTER TO RETURN ADDRESS IN HL
	DEC HL      ;BACKTRACK TO DATA 2 BYTE
	LD D,(HL)
	LD E,A      ;COMPLETE DATA 1,2 IN DE
	LD (r0syscalldata&$FFFF),DE ;FOR DEBUGGING/ERROR REPORTING PURPOSES
	LD.LIL HL,($F10000)   ;WDT GET CURRENT TIME
	LD A,%00010001        ;WDT ENABLE, DISABLE INTERRUPT GEN, USE 32KHZ CLOCK
	LD.LIL ($F1000C),A    ;WDT STATUS REGISTER WRITE
	LD.LIL ($F10004),HL   ;WDT WRITE NEW RESET VALUE
	LD A,I  ;MAINTAIN INTERRUPT STATE AFTER EXIT
	DI
	PUSH.L AF  ;PUSH FLAGS TO SPL
	JP.LIL +_
.ASSUME ADL=1
_:	LD A,D
	ADD A,A
	JR C,r0rc_boot
	JP M,r0rc_os
r0rc_app:
	LD HL,$004000  ;PLACEHOLDER FOR WHEN SUPPORT IS ADDED
	JR r0rc_coll
r0rc_boot:
	LD HL,bcall_sbase_boot-$008018
	JR r0rc_coll
r0rc_os:
	LD HL,bcall_sbase_os-$004000
r0rc_coll:
	ADD HL,DE
	LD DE,(HL)
	LD (r0rc_csmc),DE
	POP.S DE \	POP.S HL \	POP.S AF
	;JP.SIS (+_)&$FFFF
r0rc_csmc .EQU $+1
	CALL 0
	JP.SIS (+_)&$FFFF
.ASSUME ADL=0
_:	PUSH AF
	PUSH HL
		LD.LIL A,($F10010)
		AND 1
		JR Z,_
		CALL __MANUAL_NMI_SCREEN_UPDATE&$FFFF
		JR ++_
_:		LD.LIL HL,($F10000)
		LD.LIL ($F10004),HL
		LD A,%00010101
		LD.LIL($F1000C),A
_:	POP HL
	POP.L AF  ;POP FLAGS FROM SPL
	JP PO,_&$FFFF
	EI
_:  POP AF
	RET
r0syscalldata:
.dw 0
	
	
	
	
	
	
	





r0_bootxora:
	XOR A
donothing:
	RET

